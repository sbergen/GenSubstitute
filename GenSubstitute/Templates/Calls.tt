<#@ template language="C#" #>
<#@ import namespace="System.Collections.Generic" #>
using System;

namespace GenSubstitute
{
<#
    // These are here mostly because T4 doesn't support Linq :(
    var genericArgs = new List<string>();
    var constructorArgsList = new List<string>();
    var argMembersList = new List<string>();
    var valueMembersList = new List<string>();
    var executeArgsList = new List<string>();
    var executeCallList = new List<string>();
    var ctorBodyList = new List<string>();
    var receivedCtorBodyList = new List<string>();
    var callArgMatchList = new List<string>();
    var argMemberValuesList = new List<string>();
    var argMemberNamesList = new List<string>();
    
    for (var i = 0; i < 17; ++i)
    {
        if (i > 0)
        {
            genericArgs.Add($"TArg{i}");
            constructorArgsList.Add($"Arg<TArg{i}> arg{i}");
            argMembersList.Add($"        private readonly Arg<TArg{i}> _arg{i};");
            valueMembersList.Add($"        public readonly TArg{i} Arg{i};");
            executeArgsList.Add($"TArg{i} arg{i}");
            executeCallList.Add($"arg{i}");
            ctorBodyList.Add($"            _arg{i} = arg{i};");
            receivedCtorBodyList.Add($"            Arg{i} = arg{i};");
            callArgMatchList.Add($"            && _arg{i}.Matches(c.Arg{i})");
            argMemberValuesList.Add($"{{Arg{i}?.ToString() ?? \"null\"}}");
            argMemberNamesList.Add($"Arg{i}");
        }
        
        // <TArg, ..., TReturn>
        var funcGenerics = $"<{string.Join(", ", genericArgs)}{(i > 0 ? ", " : "")}TReturn>";
        
        // <TArg, ...>
        var actionGenerics = i > 0 ? $"<{string.Join(", ", genericArgs)}>" : "";
        
        // Arg<T1> arg1, ... 
        var constructorArgs = string.Join(", ", constructorArgsList);
        
        // private readonly Arg<T1> _arg1; 
        // ...
        var argMembers = string.Join("\n", argMembersList);
        
        // public readonly T1 Arg1; 
        // ...
        var valueMembers = string.Join("\n", valueMembersList);

        // TArg1 arg1, ...
        var executeArgs = string.Join(", ", executeArgsList);
        
        // arg1, ...
        var executeCall = string.Join(", ", executeCallList);
        
        // _arg1 = arg1;
        // ...
        var constructorBody = string.Join("\n", ctorBodyList);
        
        // Arg1 = arg1;
        // ...
        var receivedCtorBody = string.Join("\n", receivedCtorBodyList);
        
        // && _arg1.Matches(c.Arg1)
        // ...
        var callArgMatcher = string.Join("\n", callArgMatchList);
        
        // {Arg1?.ToString() ?? "null"}, ...
        var argMemberValues = string.Join(", ", argMemberValuesList);
        
        // Arg1, ...
        var argMemberNames = string.Join(", ", argMemberNamesList);
        
#>
    public class ConfiguredFunc<#= funcGenerics #> : IConfiguredCall
    {
<#= argMembers #>
        private Func<#= funcGenerics #>? _execute;
        private TReturn? _returnValue;
        private bool _isConfigured;

<#
        if (constructorArgs.Length > 0)
        {#>
        public ConfiguredFunc(<#= constructorArgs #>)
        {
<#= constructorBody #>
        }

<#
        }#>
        public void Configure(Func<#= funcGenerics #> implementation)
        {
            ThrowIfConfigured();
            _execute = implementation;
        }

        public void Returns(TReturn value)
        {
            ThrowIfConfigured();
            _returnValue = value;
        }

        public TReturn Execute(<#= executeArgs #>)
        {
            if (!_isConfigured)
            {
                throw new InvalidOperationException("Method call was not fully configured");
            }
            
            if (_execute != null)
            {
                return _execute(<#= executeCall #>);
            }
            else
            {
                return _returnValue!;
            }
        }

        public bool Matches(IReceivedCall call) =>
            call is ReceivedCall<#= actionGenerics #> c
            && c.ReturnType == typeof(TReturn)
<#= callArgMatcher #>;

        private void ThrowIfConfigured()
        {
            if (_isConfigured)
            {
                throw new InvalidOperationException("Method call was already configured");
            }

            _isConfigured = true;
        }
    }

    public class ConfiguredAction<#= actionGenerics #> : IConfiguredCall
    {
<#= argMembers #>
        private Action<#= actionGenerics #>? _execute;
    
<#
        if (constructorArgs.Length > 0)
        {#>
        public ConfiguredAction(<#= constructorArgs #>)
        {
<#= constructorBody #>
        }
        
<#
        }#>
        public void Configure(Action<#= actionGenerics #> implementation)
        {
            if (_execute != null)
            {
                throw new InvalidOperationException("Method call was already configured");
            }

            _execute = implementation;
        }

        public void Execute(<#= executeArgs #>)
        {
            if (_execute != null)
            {
                _execute(<#= executeCall #>);
            }
            else
            {
                throw new InvalidOperationException("Method call was not fully configured");
            }
        }

        public bool Matches(IReceivedCall call) =>
            call is ReceivedCall<#= actionGenerics #> c
            && c.ReturnType == typeof(void)
<#= callArgMatcher #>;
    }

    public class ReceivedCall<#= actionGenerics #> : IReceivedCall
    {
        public string MethodName { get; }
        public readonly Type ReturnType;
<#= valueMembers #>
        public ReceivedCall(string methodName, Type returnType<#= executeArgs.Length == 0 ? "" : ", " #><#= executeArgs #>)
        {
            MethodName = methodName;
            ReturnType = returnType;
<#= receivedCtorBody #>
        }

        public override string ToString() =>
            $"{ReturnType.Name} {MethodName}(<#= argMemberValues #>)";

        public object?[] GetArguments() => new object?[] { <#= argMemberNames #> };
    }

<#
    }
#>
}
