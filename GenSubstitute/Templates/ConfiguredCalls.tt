<#@ template language="C#" #>
<#@ import namespace="System.Collections.Generic" #>
using System;

namespace GenSubstitute
{
<#
    // These are here mostly because T4 doesn't support Linq :(
    var genericArgs = new List<string>();
    var constructorArgsList = new List<string>();
    var argMembersList = new List<string>();
    var valueMembersList = new List<string>();
    var executeArgsList = new List<string>();
    var executeCallList = new List<string>();
    var ctorBodyList = new List<string>();
    var receivedCtorBodyList = new List<string>();
    var callArgMatchList = new List<string>();
    
    for (var i = 0; i < 17; ++i)
    {
        if (i > 0)
        {
            genericArgs.Add($"TArg{i}");
            constructorArgsList.Add($"Arg<TArg{i}> arg{i}");
            argMembersList.Add($"        private readonly Arg<TArg{i}> _arg{i};");
            valueMembersList.Add($"        public readonly TArg{i} Arg{i};");
            executeArgsList.Add($"TArg{i} arg{i}");
            executeCallList.Add($"arg{i}");
            ctorBodyList.Add($"            _arg{i} = arg{i};");
            receivedCtorBodyList.Add($"            Arg{i} = arg{i};");
            callArgMatchList.Add($"            && _arg{i}.Matches(c.Arg{i})");
        }
        
        // <TArg, ..., TReturn>
        var funcGenerics = $"<{string.Join(", ", genericArgs)}{(i > 0 ? ", " : "")}TReturn>";
        
        // <TArg, ...>
        var actionGenerics = i > 0 ? $"<{string.Join(", ", genericArgs)}>" : "";
        
        // Arg<T1> arg1, ... 
        var constructorArgs = string.Join(", ", constructorArgsList);
        
        // private readonly Arg<T1> _arg1; 
        // ...
        var argMembers = string.Join("\n", argMembersList);
        
        // public readonly T1 Arg1; 
        // ...
        var valueMembers = string.Join("\n", valueMembersList);

        // TArg1 arg1, ...
        var executeArgs = string.Join(", ", executeArgsList);
        
        // arg1, ...
        var executeCall = string.Join(", ", executeCallList);
        
        // _arg1 = arg1;
        // ...
        var constructorBody = string.Join("\n", ctorBodyList);
        
        // Arg1 = arg1;
        // ...
        var receivedCtorBody = string.Join("\n", receivedCtorBodyList);
        
        // && _arg1.Matches(c.Arg1)
        // ...
        var callArgMatcher = string.Join("\n", callArgMatchList);
#>
    public class ConfiguredFunc<#= funcGenerics #> : IConfiguredCall
    {
<#= argMembers #>
        private Func<#= funcGenerics #>? _execute;
        private TReturn? _returnValue;

<#
        if (constructorArgs.Length > 0)
        {#>
        public ConfiguredFunc(<#= constructorArgs #>)
        {
<#= constructorBody #>
        }

<#
        }#>
        public void Configure(Func<#= funcGenerics #> implementation)
        {
            _execute = implementation;
            _returnValue = default;
        }

        public void Returns(TReturn value)
        {
            _execute = null;
            _returnValue = value;
        }

        public TReturn Execute(<#= executeArgs #>) => (_execute, _returnValue) switch
        {
            ({ } execute, _) => execute(<#= executeCall #>),
            (_, { } returnValue) => returnValue,
            _ => throw new InvalidOperationException("Method call was not fully configured!"),
        };

        public bool Matches(IReceivedCall call) =>
            call is ReceivedCall<#= actionGenerics #> c
            && c.ReturnType == typeof(TReturn)
<#= callArgMatcher #>;
    }

    public class ConfiguredAction<#= actionGenerics #> : IConfiguredCall
    {
<#= argMembers #>
        private Action<#= actionGenerics #>? _execute;
    
<#
        if (constructorArgs.Length > 0)
        {#>
        public ConfiguredAction(<#= constructorArgs #>)
        {
<#= constructorBody #>
        }
        
<#
        }#>
        public void Configure(Action<#= actionGenerics #> implementation)
        {
            _execute = implementation;
        }

        public void Execute(<#= executeArgs #>) =>
            _execute?.Invoke(<#= executeCall #>);

        public bool Matches(IReceivedCall call) =>
            call is ReceivedCall<#= actionGenerics #> c
            && c.ReturnType == typeof(void)
<#= callArgMatcher #>;
    }

    public class ReceivedCall<#= actionGenerics #> : IReceivedCall
    {
        public readonly Type ReturnType;
<#= valueMembers #>
        public ReceivedCall(Type returnType<#= executeArgs.Length == 0 ? "" : ", " #><#= executeArgs #>)
        {
            ReturnType = returnType;
<#= receivedCtorBody #>
        }
    }

<#
    }
#>
}
